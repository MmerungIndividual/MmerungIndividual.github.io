<!DOCTYPE html>
<html lang="en">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="欢迎来到我的博客，学艺不精">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        移动测试 - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>

<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 带学生博客，无精细打理，如有错误，请多包涵 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/zhemu.jpg" />
        </div>
        <div class="name">
            <i>WeiJian Huang</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第一章基础知识"><span class="toc-text">第一章基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-四种测试用例"><span class="toc-text">1.四种测试用例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-测试方法"><span class="toc-text">2.测试方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selenium的八种定位方式"><span class="toc-text">selenium的八种定位方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第三章GUI自动化"><span class="toc-text">第三章GUI自动化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#selenium简介"><span class="toc-text">selenium简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selenium主要功能"><span class="toc-text">selenium主要功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selenium工作原理步骤"><span class="toc-text">selenium工作原理步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#selenium使用http协议的原因"><span class="toc-text">selenium使用http协议的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器驱动可以处理Java又可以处理Python脚本呢？"><span class="toc-text">浏览器驱动可以处理Java又可以处理Python脚本呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试数据解耦和数据驱动"><span class="toc-text">测试数据解耦和数据驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据驱动的模块化思想"><span class="toc-text">数据驱动的模块化思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pytest的特点"><span class="toc-text">pytest的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pytest使用准则"><span class="toc-text">pytest使用准则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#断言的意义"><span class="toc-text">断言的意义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章http协议"><span class="toc-text">第五章http协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#web服务器"><span class="toc-text">web服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#web服务器和URL"><span class="toc-text">web服务器和URL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL分段分析"><span class="toc-text">URL分段分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http协议"><span class="toc-text">http协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#协议原理"><span class="toc-text">协议原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器地址栏键入URL回车后发生的流程"><span class="toc-text">浏览器地址栏键入URL回车后发生的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http发展历史"><span class="toc-text">http发展历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七层OSI模型和TCP-IP模型"><span class="toc-text">七层OSI模型和TCP/IP模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http的特点"><span class="toc-text">http的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http的请求"><span class="toc-text">http的请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http的请求方式"><span class="toc-text">http的请求方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get和post的区别"><span class="toc-text">get和post的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http状态码"><span class="toc-text">http状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http的不足"><span class="toc-text">http的不足</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https介绍"><span class="toc-text">https介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https加密认证"><span class="toc-text">https加密认证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对称加密和非对称加密"><span class="toc-text">对称加密和非对称加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https的不足"><span class="toc-text">https的不足</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章fiddler抓包"><span class="toc-text">第六章fiddler抓包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章cookie和session"><span class="toc-text">第七章cookie和session</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是cookie和session"><span class="toc-text">什么是cookie和session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session和cookie的作用是？"><span class="toc-text">session和cookie的作用是？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie是什么？"><span class="toc-text">cookie是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是session？"><span class="toc-text">什么是session？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie和session的区别"><span class="toc-text">cookie和session的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第九章git"><span class="toc-text">第九章git</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#git基本操作"><span class="toc-text">git基本操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十章Jenkins"><span class="toc-text">第十章Jenkins</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Jenkins是什么"><span class="toc-text">Jenkins是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CI-CD是什么"><span class="toc-text">CI/CD是什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十一章性能测试"><span class="toc-text">第十一章性能测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是软件性能？"><span class="toc-text">1.什么是软件性能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-什么是性能测试："><span class="toc-text">2.什么是性能测试：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-性能测试主要测试什么："><span class="toc-text">3.性能测试主要测试什么：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-性能测试指标及其意义（概念）："><span class="toc-text">4.性能测试指标及其意义（概念）：</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 带学生博客，无精细打理，如有错误，请多包涵 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        移动测试
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-06-30 16:08:54</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#答案" title="答案">答案</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="第一章基础知识"><a href="#第一章基础知识" class="headerlink" title="第一章基础知识"></a>第一章基础知识</h1><h2 id="1-四种测试用例"><a href="#1-四种测试用例" class="headerlink" title="1.四种测试用例"></a>1.四种测试用例</h2><p>功能性测试用例<br>安全性测试用例<br>性能压力测试用例<br>兼容性测试用例</p>
<h2 id="2-测试方法"><a href="#2-测试方法" class="headerlink" title="2.测试方法"></a>2.测试方法</h2><p>等价划分⽅法：将所有输⼊划分为若⼲个⼦集，在每个⼦集中如果任意⼀个输⼊数据 对于揭露程序中潜在的错误都具有相同的效果，那么这样的⼦集就构成了⼀个等价 类。后续只要从每个等价类中任意选取⼀个值进⾏测试，就可以⽤少量具有代表性的 测试输⼊取得较好的测试覆盖效果；<br>边界值分析⽅法： 是选取输⼊，输出的边界值进⾏测试，因为通常⼤量的软件错误是 发⽣在输⼊或者输出范围的边界上，所以需要对边界值进⾏重点测试，通常选取正好 等于，刚刚⼤于或公刚刚⼩于边界的值作为测试数据；<br>错误推测⽅法：基于被测软件系统设计的理解，过往经验以及个⼈直觉，推测出软件 可能存在的缺陷，从⽽有针对性的设计测试⽤例的⽅法。强调对被测软件的需求理解 以及设计实现的细节把握，以及个⼈能⼒和经验。</p>
<h2 id="selenium的八种定位方式"><a href="#selenium的八种定位方式" class="headerlink" title="selenium的八种定位方式"></a>selenium的八种定位方式</h2><p>❖ By.id() 通过id定位<br>❖ By.name() 通过name 定位<br>❖ By.xpath() 通过xpath定位<br>❖ By.className() 通过className定位<br>❖ By.cssSelector() 通过CSS 定位<br>❖ By.linkText() 通过linkText<br>❖ By.tagName() 通过tagName<br>❖ By.partialLinkText() 通过匹到的部分linkText</p>
<h1 id="第三章GUI自动化"><a href="#第三章GUI自动化" class="headerlink" title="第三章GUI自动化"></a>第三章GUI自动化</h1><h2 id="selenium简介"><a href="#selenium简介" class="headerlink" title="selenium简介"></a>selenium简介</h2><p>Selenium是⼀一个⽤用于Web应⽤用程序 ⾃自动化测试⼯工具。Selenium测试直 接运⾏行行在浏览器器中，就像真正的⽤用 户在操作⼀一样。Selenium并提供⼀一 套测试函数，⽤用于⽀支持Web⾃自动化 测试，函数⾮非常灵活，能够完成界 ⾯面元素定位、窗⼝口跳转、结果⽐比较 等。</p>
<h2 id="selenium主要功能"><a href="#selenium主要功能" class="headerlink" title="selenium主要功能"></a>selenium主要功能</h2><p>1）多浏览器⽀支持：可以对多浏览器进行测试，如支持的浏览器包括IE（7, 8, 9, 10, 11），Mozilla Firefox，Safari，Google Chrome，Opera等。<br>2）支持多种语言：如Java、C#、Python、Ruby、PHP等。<br>3）支持多种操作系统：如Windows、Linux、IOS、Android等。<br>4）开源免费。</p>
<h2 id="selenium工作原理步骤"><a href="#selenium工作原理步骤" class="headerlink" title="selenium工作原理步骤"></a>selenium工作原理步骤</h2><p>❖当使⽤用 Selenium 2.0 启动浏览器时，后台会同时启动基于 WebDriver Wire 协议的 Web Service 作为 Selenium 的 Remote Server，并与浏览器绑定。之后，Remote Server 就开始监听 Client 端的操作请求；<br>❖执⾏行行测试时，测试⽤用例例会作为 Client 端，将需要执⾏行行的⻚页⾯面操作请求以 Http Request 的⽅方式发送给 Remote Server 。 该 Http Request 的 body，是以 WebDriver Wire 协议规定的 JSON 格式来描述需要浏览器执⾏行行的具体操作；<br>❖Remote Server 接收到请求后，会对请求进⾏行行解析，并将解析结果发给 WebDriver，由WebDriver 实际执⾏行行浏览器的操作；<br>❖WebDriver 可以看做是直接操作浏览器的原⽣生组件（Native Component），所以搭建测试环境时，通常都需要先下载浏览器对应的 WebDriver。</p>
<h2 id="selenium使用http协议的原因"><a href="#selenium使用http协议的原因" class="headerlink" title="selenium使用http协议的原因"></a>selenium使用http协议的原因</h2><p>• 因为HTTP协议是⼀个浏览器和Web服务器之间通信的标准协议，⽽⼏乎每⼀种编程语⾔ 都提供了丰富的http libraries，这样就可以⽅便的处理客户端Client和服务器Server之间的 请求request及响应response，WebDriver的结构中就是典型的C/S结构，WebDriver API 相当于是客户端，浏览器驱动是服务器端。</p>
<h2 id="浏览器驱动可以处理Java又可以处理Python脚本呢？"><a href="#浏览器驱动可以处理Java又可以处理Python脚本呢？" class="headerlink" title="浏览器驱动可以处理Java又可以处理Python脚本呢？"></a>浏览器驱动可以处理Java又可以处理Python脚本呢？</h2><p>因为WebDriver是基于JSON Wire Protocol的，它是在HTTP协议的基础上，对HTTP请求 及响应信息的BODY部分的数据进⼀步规范, BODY部分主要传送具体的数据，在 WebDriver中这些数据都是以JSON的形式存在并进⾏传送的，这就是JSON Wire protocol。所以在Client和Server之间，只要是基于JSON Wire Protocol来传递数据，就与 具体的脚本语⾔⽆关了，这样同⼀个浏览器的驱动就即可以处理Java语⾔的脚本，也可以 处理Python语⾔的脚本了。</p>
<h2 id="测试数据解耦和数据驱动"><a href="#测试数据解耦和数据驱动" class="headerlink" title="测试数据解耦和数据驱动"></a>测试数据解耦和数据驱动</h2><p>如果测试脚本灵活性很低，且对于那些具有相同页面操作而只是输入的数据不同的用例来说，存在大量重复代码。<br>解决：将测试脚本与测试数据分为两个文件，将测试数据存为表格，每读一行就将这一行数据传给脚本并得到测试结果。于是乎表格文件多少行测试用例就会执行几次。<br>这种数据驱动的思想还适用于API测试，接口测试，单元测试等。</p>
<h2 id="数据驱动的模块化思想"><a href="#数据驱动的模块化思想" class="headerlink" title="数据驱动的模块化思想"></a>数据驱动的模块化思想</h2><p>❖ 测试数据和测试脚本分离；<br>❖ 模块化思想：通⽤操作打包成函数（登录，登出，搜 索）<br>❖ 以页⾯为对象模型：class XXpage{}</p>
<h2 id="pytest的特点"><a href="#pytest的特点" class="headerlink" title="pytest的特点"></a>pytest的特点</h2><p>❖ 简单灵活，容易上⼿；<br>❖ ⽀持参数化；<br>❖ 能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium/appnium等自动化测试、接口自动化测试（pytest+requests）;<br>❖ pytest具有很多第三方插件，并且可以⾃定义扩展，比较好用的如pytestselenium（集成selenium）、pytest-html（完美html测试报告⽣成）、pytestrerunfailures（失败case重复执⾏）、pytest-xdist（多CPU分发）等；<br>❖ 测试⽤例的skip和xfail处理；<br>❖ 可以很好的和jenkins集成。</p>
<h2 id="pytest使用准则"><a href="#pytest使用准则" class="headerlink" title="pytest使用准则"></a>pytest使用准则</h2><p>• pytest只能识别以test<em>开头和<em>test结尾的.py⽂件，识别以test.开头的所有方法、类 ；<br>• 测试类必须以Test开头，并且不能有  __init</em></em>方法；<br>• 如果当前文件夹下有多个文件，test_sample2.py ， test_sample3.py 想 要运行所有的测试用例，只需要运行命令：pytest就可以了。如果运行单个文件，则运行命令： pytest test_sample2.py ；<br>• 断言使用基本的assert即可。</p>
<h2 id="断言的意义"><a href="#断言的意义" class="headerlink" title="断言的意义"></a>断言的意义</h2><p>断言是写自动化测试基本最重要的一步，一个用例没有断言，就失去了自动化测试的意义。<br>简单来讲就是实际结果和期望结果去对比，符合预期那就测试pass，不符合预期那就测试 failed。</p>
<h1 id="第五章http协议"><a href="#第五章http协议" class="headerlink" title="第五章http协议"></a>第五章http协议</h1><h2 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h2><p>是指能够为发出请求的浏览器提供文档的程序。服务器是一种被动的程序，只有当我们从浏览器发出请求时才会响应。 （写⽹网站：是需要把我们所写的代码部署到web服务器上，这样就可以让全世界的 ⼈人都能够去访问你的网站，你那⾥里里⾯面放置的所有的数据、资源，大家都可以下载。目前主流的三个Web服务器是Apache，Nginx，IIS）</p>
<h2 id="web服务器和URL"><a href="#web服务器和URL" class="headerlink" title="web服务器和URL"></a>web服务器和URL</h2><p>HTTP使用统一资源标识符（Uniform Resource Identiﬁers, URI）来传输数据和建立连接。<br>URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息。<br>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。</p>
<h2 id="URL分段分析"><a href="#URL分段分析" class="headerlink" title="URL分段分析"></a>URL分段分析</h2><p>对于这个url：<br><strong><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name" target="_blank" rel="noopener">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></strong><br>❖ 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符。<br>❖ 域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使⽤用IP地址作为域名使用。<br>❖  端口部分：跟在域名后⾯面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分， 如果省略略端口部分，将采用默认端口。<br>❖  虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录<br>也不不是一个 URL必须的部分。本例中的虚拟目录是“/news/”。<br>❖  文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为⽌止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都 是文件名部分。本例例中的文件名是“index.asp”。文件名部分也不不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。<br>❖  锚部分：从“#”开始到最后，都是锚部分。本例例中的锚部分是“name”。锚部分也不不是一个URL必须的部分<br>❖  参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例例中的参数部分为：<br>“boardID=5&amp;ID=24618&amp;page=1”</p>
<h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML文件，图片文件，查询结果等）。</p>
<h2 id="协议原理"><a href="#协议原理" class="headerlink" title="协议原理"></a>协议原理</h2><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web⻚页⾯面传送给客户端。HTTP协议采用了了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<h2 id="浏览器地址栏键入URL回车后发生的流程"><a href="#浏览器地址栏键入URL回车后发生的流程" class="headerlink" title="浏览器地址栏键入URL回车后发生的流程"></a>浏览器地址栏键入URL回车后发生的流程</h2><p>• 浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址;<br>• 解析出IP地址后，根据该IP地址和默认端口 80，和服务器建立TCP连接;<br>• 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器;<br>• 服务器对浏览器请求作出响应，并把对应的 html文本发送给浏览器;<br>• 释放 TCP连接;<br>• 浏览器将该html文本并显示内容;</p>
<h2 id="http发展历史"><a href="#http发展历史" class="headerlink" title="http发展历史"></a>http发展历史</h2><img src="/img/httpfazhan.png" class="" width="400" height="400">
<h2 id="七层OSI模型和TCP-IP模型"><a href="#七层OSI模型和TCP-IP模型" class="headerlink" title="七层OSI模型和TCP/IP模型"></a>七层OSI模型和TCP/IP模型</h2><img src="/img/httpcen.png" class="" width="400" height="400">
<h2 id="http的特点"><a href="#http的特点" class="headerlink" title="http的特点"></a>http的特点</h2><p>• 基于请求—响应的模式：HTTP协议规定,请求从客户端发出,最后服务器端响应 该请求并返回。换句句话说,肯定是先从客户端开始建立通信的,服务器端在没有接收到请求之前不会发送响应。<br>•无状态保存：HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别,协议对于发送过的请求或响应都不做持久化处理。HTTP/1.1虽然是无状态协议,但为了了实现期望的保持状态功能, 于是引入了Cookie技术。有了了Cookie再用HTTP协议通信,就可以管理状态了。<br>•无连接：无连接的含义是限制每次连接只处理理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。<br>注意：早期的http协议是一个请求一个响应之后，直接就断开了，但是现在的http协议1.1版本不是直接就断开，而是等几秒钟，这几秒钟是等着用户如果有后续的操作与否，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数。</p>
<h2 id="http的请求"><a href="#http的请求" class="headerlink" title="http的请求"></a>http的请求</h2><p>• HTTP请求协议包括：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。<br>• 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。</p>
<h2 id="http的请求方式"><a href="#http的请求方式" class="headerlink" title="http的请求方式"></a>http的请求方式</h2><p>HTTP1.1定义请求方法：GET, POST, HEAD,OPTIONS, PUT, DELETE, TRACE 和 CONNECT。<br><img src="/img/fangshi.png" class="" width="400" height="400"></p>
<h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><p>1）GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，例如 ：EditPosts.aspx?name=test1&amp;id=123456。POST方法是把提交的数据放在HTTP包的 Body中。<br>2）GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。<br>3）GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用 户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</p>
<h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>状态代码有三位数字组成，第一个数字定义了了响应的类别，共分五种类别:<br>1xx：指示信息—表示请求已接收，继续处理。<br>2xx：成功—表示请求已被成功接收、理解、        接受。<br>3xx：重定向—要完成请求必须进行更进一步的操作。<br>4xx：客户端错误—请求有语法错误或请求无法实现。<br>5xx：服务器端错误—服务器未能实现合法的请求。<br>常见状态码：<br>200 OK   //客户端请求成功。<br>400 Bad Request  //客户端请求有语法错误，不能被服务器所理理解。<br>401 Unauthorized   //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。<br>403 Forbidden   //服务器收到请求，但是拒绝提供服务。<br>404 Not Found   //请求资源不存在。eg：输入了错误的URL。<br>500 Internal Server Error   //服务器发⽣生不可预期的错误。<br>503 Server Unavailable   //服务器当前不能处理客户端的请求，一段时间后可能恢复正常。</p>
<h2 id="http的不足"><a href="#http的不足" class="headerlink" title="http的不足"></a>http的不足</h2><p>❖ 通信使用明文，内容可能会被窃听 —— 加密通信线路。<br>❖ 不验证通信方，可能遭遇伪装 —— 证书。<br>❖ ⽆法验证报文的完整性，可能已被篡改 —— 数字签名。</p>
<h2 id="https介绍"><a href="#https介绍" class="headerlink" title="https介绍"></a>https介绍</h2><p>HTTP协议中没有加密机制,但可以通过和SSL(Secure Socket Layer,安全套接层 )或TLS(Transport Layer Security,安全层传输协议)的组合使用,加密HTTP的通信内容。属于通信加密，即在整个通信线路中加密。<br>HTTP + 加密 + 认证 + 完整性保护 = HTTPS (HTTP Secure)<br><img src="/img/anquan.png" class="" width="400" height="400"></p>
<h2 id="https加密认证"><a href="#https加密认证" class="headerlink" title="https加密认证"></a>https加密认证</h2><p>HTTPS 采⽤共享密钥加密（对称）和公开密钥加密（⾮对称）两者并⽤的混合加密制。若密钥能够实现安全交换,那么有可能会考虑仅使⽤公开密钥加密来通信。但是公开密钥加密与共享密钥加密相⽐,其处理速度要慢。</p>
<h2 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h2><p>对称加密的特点是文件加密和解密都是使用相同的密钥，因此密钥需要在加密方和解密方传输，导致密钥容易泄露和被破解。步骤如下：<br>1）甲方选择某一种加密规则，对信息进行加密；<br>2）乙方使用同一种规则，对信息进行解密。<br>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密， 根据公开的公钥无法测算出另一不公开的密钥（即为私钥），而私有密钥保存在解密方本地，只要解密方自己不泄露出去，私钥就没有泄露的可能。非对称加密很好地克服了对称加密算法的弱点。</p>
<h2 id="https的不足"><a href="#https的不足" class="headerlink" title="https的不足"></a>https的不足</h2><p>❖ 加密解密过程复杂，导致访问速度慢；<br>❖ 加密需要认向证机构付费；<br>❖ 整个页⾯的请求都要使⽤HTTPS。</p>
<h1 id="第六章fiddler抓包"><a href="#第六章fiddler抓包" class="headerlink" title="第六章fiddler抓包"></a>第六章fiddler抓包</h1><p>1) 客户端像WEB服务器发送HTTP(S)请求时，请求会先经过Fiddler代理服务器。<br>2) Fiddler代理服务器截取客户端的请求报文，再转发到WEB服务器，转发之前可以做一些请求报文参数修改的操作。<br>3) WEB服务器处理完请求以后返回响应报文，Fiddler代理服务器会截取WEB服务器的响应报文。<br>4) Fiddler处理完响应报文后再返回给客户端。</p>
<h1 id="第七章cookie和session"><a href="#第七章cookie和session" class="headerlink" title="第七章cookie和session"></a>第七章cookie和session</h1><h2 id="什么是cookie和session"><a href="#什么是cookie和session" class="headerlink" title="什么是cookie和session"></a>什么是cookie和session</h2><p>在程序中，会话跟踪是很重要的事情。理论上，⼀个⽤户的所有请求操作都应该属于 同⼀个会话，⽽另⼀个⽤户的所有请求操作则应该属于另⼀个会话，⼆者不能混淆。 例如，⽤户A在超市购买的任何商品都应该放在A的购物车内，不论是⽤户A什么时间 购买的，这都是属于同⼀个会话的，不能放⼊⽤户B或⽤户C的购物车内，这不属于同 ⼀个会话。⽽Web应⽤程序是使⽤HTTP协议传输数据的。HTTP协议是⽆状态的协 议。⼀旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建⽴ 新的连接。这就意味着服务器⽆法从连接上跟踪会话。即⽤户A购买了⼀件商品放⼊购 物车内，当再次购买商品时服务器已经⽆法判断该购买⾏为是属于⽤户A的会话还是⽤ 户B的会话了。要跟踪该会话，必须引⼊⼀种机制。Cookie就是这样的⼀种机制。它可 以弥补HTTP协议⽆状态的不⾜。在Session出现之前，基本上所有的⽹站都采⽤ Cookie来跟踪会话。</p>
<h2 id="session和cookie的作用是？"><a href="#session和cookie的作用是？" class="headerlink" title="session和cookie的作用是？"></a>session和cookie的作用是？</h2><p>会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的会话跟踪技术是Cookie与Session。Cookie通过在客户端记录信息确定用户身份。</p>
<h2 id="cookie是什么？"><a href="#cookie是什么？" class="headerlink" title="cookie是什么？"></a>cookie是什么？</h2><p>Cookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的⼀种机制。⽬前 Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都⽀持 Cookie。 　　Cookie实际上是⼀⼩段的⽂本信息。客户端请求服务器，如果服务器需要记录该⽤ 户状态，就使⽤response向客户端浏览器颁发⼀个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该⽹站时，浏览器把请求的⽹址连同该Cookie⼀同提交给服务器。服务器检查该Cookie，以此来辨认⽤户状态。服务器还可以根据需要修改Cookie的内容。</p>
<h2 id="什么是session？"><a href="#什么是session？" class="headerlink" title="什么是session？"></a>什么是session？</h2><p>Session是服务器端使⽤的⼀种记录客户端状态的机制，使⽤上⽐Cookie简单⼀些，相应的也增加了服务器的存储压⼒。<br>Session是另⼀种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是Session。客户端浏览器再次访问时只需要从该Session 中查找该客户的状态就可以了。如果说Cookie机制是通过检查客户身上的“通行证”来 确定客户身份的话，那么Session机制就是通过检查服务器上的“客户明细表”来确认客户身份。Session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。</p>
<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><p>❖ cookie数据存放在客户的浏览器上，session数据放在服务器上.<br>❖ cookie不是很安全，别⼈可以分析存放在本地的COOKIE并进⾏COOKIE欺骗。考虑到 安全应当使⽤session。<br>❖ session会在⼀定时间内保存在服务器上。当访问增多，会⽐较占⽤你服务器的性能考 虑到减轻服务器性能⽅⾯，应当使⽤cookie。<br>❖ 单个cookie保存的数据不能超过4K，很多浏览器都限制⼀个站点最多保存20个cookie。 (Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)。<br>❖ 注：记住密码功能就是使⽤永久cookie写在客户端电脑硬盘上，下次登录时，⾃动将 cookie信息附加发送给服务端。</p>
<h1 id="第九章git"><a href="#第九章git" class="headerlink" title="第九章git"></a>第九章git</h1><h2 id="git基本操作"><a href="#git基本操作" class="headerlink" title="git基本操作"></a>git基本操作</h2><p>git status 以查看在你上次提交之后是否有修改。<br>git add 命令可将该文件添加到缓存。<br>git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。<br>使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。<br>git commit 提交</p>
<h1 id="第十章Jenkins"><a href="#第十章Jenkins" class="headerlink" title="第十章Jenkins"></a>第十章Jenkins</h1><h2 id="Jenkins是什么"><a href="#Jenkins是什么" class="headerlink" title="Jenkins是什么"></a>Jenkins是什么</h2><p>Jenkins是⼀个开源的、提供友好操作界⾯的持续集成(CI)⼯具，主要⽤于持续、⾃动的构建/测试 软件项⽬、监控外部任务的运行。</p>
<h2 id="CI-CD是什么"><a href="#CI-CD是什么" class="headerlink" title="CI/CD是什么"></a>CI/CD是什么</h2><p>CI(Continuous integration，中文意思是持续集成)是⼀种软件开发时间。持续集成强调开发⼈员提交了新代码之后，立刻进⾏构建、（单元）测试。根据测试结果，我们可以确定新代码和原有代码能否正确地 集成在一起。<br>CD(Continuous Delivery， 中⽂意思持续交付)是在持续集成的基础上，将 集成后的代码部署到更贴近真实运⾏环境(类⽣产环境)中。⽐如，我们完成 单元测试后，可以把代码部署到连接数据库的Staging环境中更多的测试。 如果代码没有问题，可以继续⼿动部署到⽣产环境。下图反应的是CI/CD 的⼤概⼯作模式。</p>
<h1 id="第十一章性能测试"><a href="#第十一章性能测试" class="headerlink" title="第十一章性能测试"></a>第十一章性能测试</h1><h2 id="1-什么是软件性能？"><a href="#1-什么是软件性能？" class="headerlink" title="1.什么是软件性能？"></a>1.什么是软件性能？</h2><p>定义：软件的性能是软件的一种非功能特性，它关注的不是软件是否能 够完成特定的功能，⽽是在完成该功能时展⽰出来的及时性。<br>由定义可知性能关注的是软件的⾮功能特性，所以⼀般来说性能测试介 ⼊的时机是在功能测试完成之后。另外，由定义中的及时性可知性能也 是⼀种指标，可以⽤时间或其它指标来衡量，通常我们会使⽤某些⼯具 或⼿段来检测软件的某些指标是否达到了要求，这就是性能测试。</p>
<h2 id="2-什么是性能测试："><a href="#2-什么是性能测试：" class="headerlink" title="2.什么是性能测试："></a>2.什么是性能测试：</h2><p>性能测试定义：指通过⾃动化的测试⼯具模拟多种正常、峰值以及异常 负载条件来对系统的各项性能指标进⾏测试 。<br>测试⼈员在做性能测试时除开要关注表⾯的现象如响应时间，也需要关注本质，比如用户看不到的服务器资料利用率，架构设计是否 合理？代码是否合理等方面。</p>
<h2 id="3-性能测试主要测试什么："><a href="#3-性能测试主要测试什么：" class="headerlink" title="3.性能测试主要测试什么："></a>3.性能测试主要测试什么：</h2><p>• 基准测试：在给系统施加较低压力时，查看系统的运行状况并记录 相关数做为基础参考。<br>• 负载测试：是指对系统不断地增加压力或增加⼀定压力下的持续时间，直到系统的某项或多项性能指标达到安全临界值，例如某种资源已经达到饱和状态等 。<br>• 压力测试：压力测试是评估系统处于或超过预期负载时系统的运行情况，关注点在于系统在峰值负载或超出最大载荷情况下的处理能力。<br>• 稳定性测试：在给系统加载⼀定业务压力的情况下，使系统运行一段时间，以此检测系统是否稳定。<br>• 并发测试：测试多个用户同时访问同一个应用、同一个模块或者数 据记录时是否存在死锁或者其他性能问题。</p>
<h2 id="4-性能测试指标及其意义（概念）："><a href="#4-性能测试指标及其意义（概念）：" class="headerlink" title="4.性能测试指标及其意义（概念）："></a>4.性能测试指标及其意义（概念）：</h2><p>❖ 响应时间：是指系统对请求作出响应的时间，可以理解为是指⽤户从客户端发起一个请求开始，到客户端接收到从服务器端返回的响应结束，整个过程所耗费的时间。直观上看，这个指标与⼈对软件性能的主观感受是⾮常⼀致的，因为它完 整地记录了整个计算机系统处理请求的时间。<br>❖ 系统处理能力：系统处理能⼒是指系统在利⽤系统硬件平台和软件平台进⾏信息处 理的能⼒。系统处理能⼒通过系统每秒钟能够处理的交易数量来评价。<br>⼀般情况下，系统处理能⼒又⽤以下⼏个指标来度量：<br>HPS（Hits Per Second）：每秒点击次数，单位是次/秒；<br>TPS（Transaction per Second）：系统每秒处理交易数，单位是笔/秒；<br>QPS（Query per Second）：系统每秒处理查询次数，单位是次/秒。<br>❖ 吞吐量：吞吐量是指系统在单位时间内处理请求的数量。对于单用户的系统，响应时间可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。<br>❖ 并发数：并发用户数指在同一时刻内，登录系统并进⾏业 务操作的用户数量。与吞吐量相⽐，并发用户数是一个更 直观但也更笼统的性能指标。实际上，并发用户数是一个⾮常不准确的指标，因为用户不同的使⽤模式会导致不同用户在单位时间发出不同数量的请求。<br>❖ 错误率：一批请求中结果出错的概率。错误率＝(失败交易 数/交易总数)*100%。不同系统对错误率的要求不同，但一般不超出千分之六，即成功率不低于99.4%</p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud" target="_blank" rel="noopener">AirCloud</a></p>
</footer>




<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
--><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
