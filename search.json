[{"title":"上网教学","url":"/2020/02/18/上网教学/","content":"科学上网：用 VPS 搭建 shadowsocks 服务器\n 分类： 网络与安全2016-01-13 16:19:11\n目前 shadowsocks 服务已经受到了影响，不过部署在 25 端口目前还可用。\n\n仍然可以通过 ubuntu 的 apt-get 获取到 shadowsocks 服务端，windows、Mac OS X、Android 客户端的 release 下载链接仍然保留。因此在写作本文时，shadowsocks 还是可以使用的。\n\nshadowsocks 简介\nshadowsocks 是一款自定义协议的代理软件，由于其流量特征不明显，（直到不久前）一直可以稳定提供上网代理。\n\nshadowsocks 客户端会在本地开启一个 socks5 代理，通过此代理的网络访问请求由客户端发送至服务端，服务端发出请求，收到响应数据后再发回客户端。\n\n因此使用 shadowsocks 需要一台墙外的服务器来部署 shadowsocks 服务端。\n\n购买 VPS 服务器\n主流的 VPS（虚拟主机）服务器提供商有三家：\n\nlinode\ndigital ocean\nbandwagon\n下面的比上面的便宜。如果只是自用，bandwagon 足够。\n\n一般使用 paypal 绑定一个 visa 或 mastercard 信用卡来付款。注意要用国际 paypal 帐号，国内的是不能用外币付款的。\n\n在 bandwagon 购买 VPS 以后会获得一个主机地址和用于 ssh 登录的 root 密码。\n\n远程登陆 VPS\nMac OS X 或 Linux 下直接在终端中 ssh root@your_vps_ip -p your_ssh_port   即可。\n\n在 windows 系统下需要专门的客户端来 SSH 登录 VPS。在 xShell 官网  下载 xShell。\n\n家庭和学校用户可以免费试用，下载时选择 home and school use 即可。需要用邮箱注册一下，下载链接会发送到邮箱中。\n\nxShell 中新建一个连接，会要求输入目标 IP 地址和端口，以及 root 密码，按提示操作即可。\n\n安装 shadowsocks\n\n最好是centos7\n1.安装pip\n\n由于安装的是python 版本的 shadowsocks，所以首先安装pip\n\n$ curl \"https://bootstrap.pypa.io/get-pip.py\" -o \"get-pip.py\"\n$ python get-pip.py\n\n2.安装shadowsocks\n$ pip install --upgrade pip\n$ pip install shadowsocks\n3.创建配置文件\n\n创建文件所在目录:/etc\n\n#创建文件命令,\n$ vi /etc/shadowsocks.json\n#若进入了etc目录\n$ vi shadowsocks.json\n\n配置文件内容：\n单端口：\n {\n \"server\":\"0.0.0.0\",            --服务器IP，直接用0.0.0.0也可\n \"server_port\":8888,            --端口端口\n \"local_address\": \"127.0.0.1\",  --本地地址，可省略\n \"local_port\":1080,             --本地端口，可省略\n \"password\":\"password\",         --密码\n \"timeout\":300,                 --超时时间，可省略\n \"method\":\"aes-256-cfb\",        --加密策略，有多重策略，具体自查\n}\n多端口：\n{\n    \"server\":\"0.0.0.0\",\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"port_password\":{           --每个端口对应一个密码\n        \"1111\":\"password1\",\n        \"1112\":\"password2\",\n        \"1113\":\"password3\"\n    },\n    \"timeout\":300,\n    \"method\":\"aes-256-cfb\",\n    \"fast_open\":false\n}\n\n4.启动shadowsocks\n#启动\nssserver -c /etc/shadowsocks.json -d start\n#停止\nssserver -c /etc/shadowsocks.json -d stop\n#重启\nssserver -c /etc/shadowsocks.json -d restart\n\n启动成功即可通过ss客户端使用。\n在window端可以在控制台通过以下命令查看端口是否打开\ntelnet {ip} {port}\n\n5.配置自启动\n新建启动脚本文件/etc/systemd/system/shadowsocks.service，内容如下：\n[Unit]\nDescription=Shadowsocks\n\n\n[Service]\nTimeoutStartSec=0\nExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json\n\n\n[Install]\nWantedBy=multi-user.target\n\n通过以下命令注册，启动服务\n$ systemctl enable shadowsocks\n$ systemctl start shadowsocks\n\n启动后可以查看服务状态\n$ systemctl status shadowsocks -l\n\n若启动成功：\n● shadowsocks.service - Shadowsocks\n   Loaded: loaded (/etc/systemd/system/shadowsocks.service; enabled; vendor preset: disabled)\n   Active: active (running) since Sun 2017-08-13 18:03:41 CST; 1h 29min ago\n Main PID: 9567 (ssserver)\n   CGroup: /system.slice/shadowsocks.service\n           └─9567 /usr/bin/python2 /usr/bin/ssserver -c /etc/shadowsocks.json\n\n如果，服务失败，重启服务器试一下\n\n安装并启动 shadowsocks 客户端\nshadowsocks 支持 windows、Mac OS X、Linux、Android、iOS 等多个平台。不过 iOS 由于系统对应用后台运行的限制，推荐使用客户端内嵌的浏览器科学上网，给其他应用代理时需要每过几分钟重新启动一下 app。\n\nshadowsocks 项目 Github 主页在这里。\n\n里面可以找到客户端下载地址。\n\n下载安装客户端以后，只需按服务器的配置填写 IP 地址、服务器端口、本地端口（如果没有本地端口选项，就是默认的 1080）、密码、加密方式等参数，启动就可以了。\n\n客户端支持全局代理和 PAC 代理两种方式，后者会使用一个脚本来自动检查一个网站是否在需要代理的网站列表中，自动选择直接连接或代理连接。\n\nPAC 列表可以在线更新，但是难免有收录不全的情况。这时可以选择关闭 shadowsocks 代理（实际上是取消对系统代理的配置，shadowsocks 客户端仍然保持工作），然后使用支持自定义规则的代理管理插件来实现自动切换代理，比如 switchyOmega。\n\n使用 switchyOmega 实现自动切换代理\nswitchyOmega 是 chrome 浏览器上一个很好用的代理管理插件。它的前身 switchySharp 更有名。\n\nchrome 应用商店本身需要翻墙才能访问，因此需要先在 shadowsocks 启动代理模式下下载安装，再关闭 shadowsocks 代理。\n\n安装完毕后，右击 switchyOmega 图标，选择选项，进入 switchOmega 配置界面。\n\n创建 shadowsocks 情景模式\n新建一个情景模式，比如叫 SS，代理协议选择 socks5，代理地址为 127.0.0.1，端口 1080。\n\n现在切换到 SS 情景模式就可以通过 shadowsocks 科学上网了。后面获取自动切换规则列表\n\n设置自动切换模式\n在设置界面选择自动切换模式，在 “切换规则” 中勾选“规则列表规则”，对应的情景模式选择刚刚新建的 SS。\n\n然后在下面的规则列表地址中填写\n\nhttps://autoproxy-gfwlist.googlecode.com/svn/trunk/gfwlist.txt\n\n规则列表格式选择 AutoProxy。\n\n然后点击立即更新情景模式， 更新完成后会有提示。\n\n点击左侧的 “应用选项”。然后单击 switchyOmega 图标，选择自动切换，就可以在访问“不存在的网站” 时自动切换到 shadowsocks 代理了。\n\n添加自定义规则\n如果遇到某个国外网站无法直接连接或速度太慢时，可以单击 switchyOmega 图标，选择 “添加条件”，情景模式选择 SS，就可以了。\n\n这时打开 switchyOmega 选项，在自动切换模式的切换规则中就可以看到刚刚添加的规则。可以在这里管理自定义的规则。\n\n导入和导出 switchyOmega 设置\n如果换了一台电脑，重新设置一遍 switchyOmega 就太麻烦了。可以在设置好的 switchyOmega 中导出设置文件，在另一个 chrome 浏览器中导入，就可以直接复制原来的设置了。\n\n在 switchyOmega 选项的左侧点击 “导入 / 导出”，点击“生成备份文件” 即可生成 switchyOmega 设置备份。点击 “从备份文件恢复” 可以导入备份文件。\n\n阅读(95842) | 评论(0) | 转发(3) |\n1\n上一篇：Server 2012建立iSCSI虚拟磁盘存储\n\n下一篇：Centos 7 安装VNC步骤\n\n给主人留下些什么吧！~~\n评论热议\n请登录后评论。\n登录 注册\n\n\n关于我们 | 关于IT168 | 联系方式 | 广告合作 | 法律声明 | 免费注册\nCopyright 2001-2010 ChinaUnix.net All Rights Reserved 北京皓辰网域网络信息技术有限公司. 版权所有\n\n感谢所有关心和支持过ChinaUnix的朋友们\n16024965号-6","tags":["杂七杂八"]},{"title":"Python数据分析与挖掘(一) 拉格朗日插值法","url":"/2020/01/03/Python数据分析与挖掘-一/","content":"拉格朗日插值法：根据数学知识可知，对于平面上已知的n个点，可以找到一个n-1次多项式，使此多项式曲线过n个点，语言：Python\n```bash\n#拉格朗日插值代码\nimport pandas as pd #导入数据分析库Pandas\nfrom scipy.interpolate import lagrange #导入拉格朗日插值函数\n\ninputfile = '../chapter4/demo/data/catering_sale.xls' #销量数据路径\noutputfile = '../chapter4/demo/data/sales.xls' #输出数据路径\ndata = pd.read_excel(inputfile) #读入数据\ndata[u'销量'][(data[u'销量'] < 400) | (data[u'销量'] > 5000)] = None #过滤异常值，将其变为空值\nprint(data.columns)\n#自定义列向量插值函数\n#s为列向量，n为被插值的位置，k为取前后的数据个数，默认为5\ndef ployinterp_column(s, n, k=5):\n  y = s[list(range(n-k, n)) + list(range(n+1, n+1+k))]#取数\n  y = y[y.notnull()] #剔除空值,返回一个没有空值的列向量\n  return lagrange(y.index, list(y))(n) #插值并返回插值结果\n\n#逐个元素判断是否需要插值\nfor i in data.columns:\n  for j in range(len(data)):\n    if (data[i].isnull())[j]: #如果为空即插值。\n      data[i][j] = ployinterp_column(data[i], j)\n\ndata.to_excel(outputfile) #输出结果，写入文件\n```\nlangrange(x,y)(n)这个函数表示插入缺失值所在的下标n，并用插值多项式得到近似值，详情请使用文档查看，jupyter查看方法：移动光标到相应位置shift+tab。","tags":["大数据技术"]},{"title":"Scala辅导班（二）集和映射","url":"/2020/01/02/Scala辅导班（二）集和映射/","content":"## 集和映射\n集（set）：可变集和不可变集\n映射（Map）：可变映射和不可变映射\n可变与不可变分别继承于scala.collection.mutable._和scala.collection.immutable._\n测试的完整代码如下\n```bash\nobject mapAndSet {\n  def main(args:Array[String]){\n    var jetSet = Set(\"test\",\"exam\")//不可变集\n    val jetSet2 = mutable.Set(\"tiny2\",\"nico\")\n    jetSet+=\"tiny\"\n    jetSet2+=\"negopa\"\n    println(jetSet)\n    println(jetSet2)\n    val treasureMap = mutable.Map[Int,String]()\n    treasureMap+=(1 -> \"My\")\n    treasureMap+=(2 -> \"Name\")\n    treasureMap+=(3 -> \"is\")\n    println(treasureMap(2))\n    val rumerNum = Map(1 -> \"I\",2 -> \"II\",3 -> \"III\",4 -> \"IV\")//不可变映射\n    rumerNum.foreach(s => println(s._2))\n  }\n}\n```","tags":["语言学习基础"]},{"title":"Scala辅导班(一) 使用列表","url":"/2019/12/31/Scala辅导班（一）使用列表/","content":"新年快乐，2020，向前冲！\n语言：scala 2.12\n## 数组定义\n```bash\nval numNames = Array(\"num1\",\"num2\",\"num3\")\n```\n数组定义的一般形式\n```bash\nval numNames2 = Array.apply(\"num1\",\"num2\",\"num3\")\n```\n数组定义的等价形式，使用apply方法，scala语言的本质\n## 列表定义\n```bash\nval OneTwo = List(1,2)\nval ThreeFour = List(3,4)\n```\n列表定义\n```bash\nval OneTwoThreeFour = OneTwo ::: ThreeFour\n```\n列表衔接\n```bash\nval TwoThreeFour = 2::ThreeFour\n```\n向表头添加元素，为什么是向头部添加，因为向后添加会消耗线性时间，与其这样不如向表头添加，再通过反转，就能完成同样的功能\n## 列表常用方法\n```bash\nval thrill = \"nil\"::\"sekiro\"::\"thunder\"::Nil\nprint(thrill.count(s => s.length>=4))\nprint(thrill.filter(s => s.length>=4))\nprint(thrill.forall(s => s.endsWith(\"l\")))\nthrill.foreach(s => println(s))\nprint(thrill.mkString(\",\"))//返回以\",\"分割组成的一个列表\n```\n自己动手实践，不多讲","tags":["语言学习基础"]},{"title":"Spark学习（二）概念梳理","url":"/2019/12/29/Spark学习（二）概念梳理/","content":"\n伟大领袖，天降伟人的刘老师给我们的spark概念图\n{% img /img/Spark.png 800 450 %}\n## 分区\nSpark的分区是逻辑上的分区。执行过程中有多少个Task是由RDD分区决定的。同时运行几个Task是由分配给Executor的Core的数量决定的。\n## 什么时候分区\n·分区数量从少到多·处理能力不够·数据倾斜·需要合并场景\n## cache缓存\n持久化方法，将RDD放入内存中，减少重复计算,一共有12种\n    例：\n    ```bash\n    val MEMORY_AND_DISK = new StorageLevel(true, true, false, true)\n    ```\n//第一个参数，放到磁盘\n    //第二个参数，放到内存\n    //第三个参数，磁盘中的数据，不是以java对象的方式保存\n    //第四个参数，内存中的数据，以java对象的方式保存\n## checkpoint机制\n将RDD存储在本地磁盘或者HDFS中，通过直接读取检查点目录的数据来恢复相应的RDD\n## 宽依赖窄依赖\n    宽依赖：一个父RDD和一个或多个子RDD\n    窄依赖：一个子RDD和一个或多个父RDD\n## 广播\n将数据块缓存到所有节点\n## 启动流程(9step)\n    1、跟Master建连接并申请资源，每个Executor需要 3g 内存，一共4 cores\n    2、Master进行资源调度\n    3、Master跟Worker进行rpc通信，让Worker创建Executor\n    4、Worker启动Executor\n    5、Executor跟Driver进行通信\n    6、RDD触发Action后，会根据最后这个RDD从后往前推断依赖关系，遇到shufle就切分Stage，会递归切分，递归的出口是某个RDD没有父BDD了\n    7、DAGScheduler切分完Stage后，先提交前面的Stage,执行完后在提交后面的Stage，Stage会生产Task，一个Stage 会生产很多业务逻辑相同的Task，然后将以TaskSet的形式传递给TaskScheduler\n    8、 TaskScheduler将Task序列化，根据资源情况，发送Task给Executor\n    9、Executor接收到Task后，先将Task反序列化，然后将Task用一个实现了Runnable接口的实现类包装起来，然后将该包装类丢入到线程池，然后包装类的run方法就会被执行，进而调用Task的计算逻辑\n## DStream\nDstream为每一批次的数据生成一个RDD实例，就是一个RDD序列\n## 几何平均数\n{% img /img/jihe.png 150 100 %}\n## UDF用户自定义函数\n一对一的用户定义函数，例如\n```bash\nspark.sql(\"SELECT name,age,from_unixtime(create_time,'yyyy-MM-dd HH:mm:ss') FROM t_usr\").show\n```\n实现用户自定义函数\n```bash\nspark.udf.register(\"func_name\",方法体)\n```\n多进一出UDAF（多对一）\n","tags":["大数据技术"]},{"title":"Spark学习（一）Spark集群模式讲解","url":"/2019/12/28/Spark学习（一）Spark集群模式讲解/","content":"  小坚又被Spark教训了，下面重点讲解Spark的集群\n  下面详细列举了Spark目前支持的部署模式。\n· Local模式：在本地部署单个Spark服务\n· Standalone模式：Spark自带的任务调度模式（国内常用)\n· Yarn模式：Spark使用Hadoop的YARN组件来进行\n· Mesos模式：Spark使用Mesos平台进行资源与任务的调度\n· Kubernetes模式：自Spark2.3.x版本之后才开始支持Kubernetes","tags":["大数据技术"]},{"title":"数据结构与算法（五）科赫曲线","url":"/2019/12/21/数据结构与算法（五）科赫曲线/","content":"语言：python\n递归就是常说的套娃，\n在递归函数中直接或间接调用函数，就是递归\n科赫曲线是在无限的长度中圈定有限的面积，\n实现为三步：1.找到三等分点S,T 2.做等边三角形 3.再对线段进行调用\n```bash\n#科赫曲线\nimport turtle as t\ndef koth(size,n):\n    if n==0:\n        t.fd(size)\n    else:\n        for seta in [0,60,-120,60]:\n            t.left(seta)\n            koth(size/3,n-1)\nif __name__ == '__main__':\n    koth(200,3)\n```","tags":["数据结构与算法"]},{"title":"数据结构与算法（四）穷举搜索","url":"/2019/12/21/数据结构与算法（四）穷举搜索/","content":"运行环境：python 3.7 Dev-C++\n判断是否A中的任意元素都能能够组成整数m?\npython版:\n```bash\nA = [1,5,7,10,21]\nn = len(A)\ndef solve(i,m):\n    if m==0:\n        return True\n    elif i>=n:\n        return False\n    res = solve(i+1,m) or solve(i+1,m-A[i])\n    return res\nif __name__ == '__main__':\n        if(solve(0,8)):\n            print(\"yes\")\n        else:\n            print(\"no\")\n```\nc语言版:\n```bash\n#include<stdio.h>\nint n,A[50];\nint solve(int i,int m){\n\tif (m ==0)return 1;\n\tif (i>=n)return 0;\n\tint res = solve(i+1,m)||solve(i+1,m-A[i]);\n\treturn res; \n} \nint main(){\n\tint q,M,i;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++) scanf(\"%d\",&A[i]);\n\tscanf(\"%d\",&q);\n\tfor(i=0;i<q;i++){\n\t  scanf(\"%d\",&M);\n\t  if(solve(0,M)) printf(\"yes\\n\");\n\t  else printf(\"no\\n\"); \n}\nreturn 0;\n}\n```\n","tags":["数据结构与算法"]},{"title":"数据结构与算法（三）分治与递归","url":"/2019/12/21/数据结构与算法（三）分治与递归/","content":"运行环境：python 3.7\n将问题分解\n函数->递归函数->分治法\n本篇介绍递归和分治\n```bash\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n*factorial(n-1)\ndef findMaximum(A,l,r):\n    m = (l+r)//2\n    if l == r-1:\n        return A[l]\n    else:\n        u = findMaximum(A,l,m)\n        v = findMaximum(A,m,r)\n        x = max(u,v)\n    return x\nif __name__ == '__main__':\n    print(factorial(4))\n    A = [1,2,4,2,3,4,6]\n    print(findMaximum(A,0,7))#l到r（不包括r）\n```\n结果如下\n![](/img/分治与递归.png)\n","tags":["数据结构与算法"]},{"title":"数据结构与算法（二）散列法","url":"/2019/12/21/数据结构与算法（二）散列法/","content":"运行环境：Dev-C++\n题目要求：\n请实现一个能执行以下命令的简单“字典”\ninsert str:向字典中添加字符串\nfind str:当前字典中包含str时输出yes，不包含str时输出no\n主要思想：将字符转变成数字，并使用散列函数H(k) = (h1(k)+i*h2(k))mod m\nh1(k)=k mod m\nh2(k)=1+ k mod (m-1)\n代码如下\n```bash\n#include<stdio.h>\n#include<string.h>\n\n#define M 1046527\n#define NIL (-1)\n#define L 14\n\nchar H[M][L];\n\nint getChar(char ch){\n\tif(ch=='A')return 1;\n\telse if(ch=='C')return 2;\n\telse if(ch=='G')return 3;\n\telse if(ch=='T')return 4;\n\telse return 0;\n} \nlong long getKey(char str[]){\n\tlong long sum=0,p=1,i;\n\tfor(i=0;i<strlen(str);i++){\n\t\tsum+=p*(getChar(str[i]));\n\t\tp*=5;\n\t}\n\treturn sum; \n}\nint h1(int key){\n\treturn key%M;\n}\nint h2(int key){\n\treturn 1+(key%(M-1));\n}\nint find(char str[]){\n\tlong long key,i,h;\n\tkey=getKey(str);\n\tfor(i=0;;i++){\n\t\th=(h1(key)+i*h2(key))%M;\n\t\tif(strcmp(H[h],str)==0)return 1;\n\t\telse if(strlen(H[h])==0)return 0;\n\t}\n\treturn 0;\n}\nint insert(char str[]){\n\tlong long key,i,h;\n\tkey = getKey(str);\n\tfor(i=0;;i++){\n\t\th=(h1(key)+i*h2(key))%M;\n\t\tif(strcmp(H[h],str)==0)return 1;\n\t\telse if(strlen(H[h])==0){\n\t\t\tstrcpy(H[h],str);\n\t\t\treturn 0;\n\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint i,n,h;\n\tchar str[L],com[9];\n\tfor(i=0;i<M;i++)H[i][0]='\\0';\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%s %s\",com,str);\n\t\t\n\t\tif(com[0]=='i'){\n\t\t\tinsert(str);\n\t\t}else{\n\t\t\tif(find(str)){\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n结果如下：\n![](/img/散列法.png)\n\n\n","tags":["数据结构与算法"]},{"title":"数据结构与算法（一）二分查找","url":"/2019/12/21/数据结构与算法（一）二分查找/","content":"运行环境：Dev-C++\n题目要求：\n有一含n个整数的数列S，含q个不相同整数的T，限制：S为升序排列\n请找出既在S又在T的整数的个数？\n代码如下\n```bash\n#include<stdio.h>\nint A[10000],n;\nbinarySearch(int key){\n\tint left=0;\n\tint right=n;\n\tint mid;\n\twhile (left<right){\t\n\t\tmid=(left+right)/2;\n\t\tif(key==A[mid])return 1;\n\t\tif(key>A[mid])left=mid+1;\n\t\telse if(key<A[mid])right=mid;\n}\n\treturn 0;\n}\nint main(){\n\tint i,q,k,sum=0;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&A[i]);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%d\",&k);\n\t\tif(binarySearch(k))sum++;\n\t}\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n} \n```\n结果如下：\n![](/img/二分查找.png)","tags":["数据结构与算法"]}]