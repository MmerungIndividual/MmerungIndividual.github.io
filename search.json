[{"title":"Python数据分析与挖掘(一) 拉格朗日插值法","url":"/2020/01/03/Python数据分析与挖掘-一/","content":"拉格朗日插值法：根据数学知识可知，对于平面上已知的n个点，可以找到一个n-1次多项式，使此多项式曲线过n个点，语言：Python\n```bash\n#拉格朗日插值代码\nimport pandas as pd #导入数据分析库Pandas\nfrom scipy.interpolate import lagrange #导入拉格朗日插值函数\n\ninputfile = '../chapter4/demo/data/catering_sale.xls' #销量数据路径\noutputfile = '../chapter4/demo/data/sales.xls' #输出数据路径\ndata = pd.read_excel(inputfile) #读入数据\ndata[u'销量'][(data[u'销量'] < 400) | (data[u'销量'] > 5000)] = None #过滤异常值，将其变为空值\nprint(data.columns)\n#自定义列向量插值函数\n#s为列向量，n为被插值的位置，k为取前后的数据个数，默认为5\ndef ployinterp_column(s, n, k=5):\n  y = s[list(range(n-k, n)) + list(range(n+1, n+1+k))]#取数\n  y = y[y.notnull()] #剔除空值,返回一个没有空值的列向量\n  return lagrange(y.index, list(y))(n) #插值并返回插值结果\n\n#逐个元素判断是否需要插值\nfor i in data.columns:\n  for j in range(len(data)):\n    if (data[i].isnull())[j]: #如果为空即插值。\n      data[i][j] = ployinterp_column(data[i], j)\n\ndata.to_excel(outputfile) #输出结果，写入文件\n```\nlangrange(x,y)(n)这个函数表示插入缺失值所在的下标n，并用插值多项式得到近似值，详情请使用文档查看，jupyter查看方法：移动光标到相应位置shift+tab。","tags":["大数据技术"]},{"title":"Scala辅导班（二）集和映射","url":"/2020/01/02/Scala辅导班（二）集和映射/","content":"## 集和映射\n集（set）：可变集和不可变集\n映射（Map）：可变映射和不可变映射\n可变与不可变分别继承于scala.collection.mutable._和scala.collection.immutable._\n测试的完整代码如下\n```bash\nobject mapAndSet {\n  def main(args:Array[String]){\n    var jetSet = Set(\"test\",\"exam\")//不可变集\n    val jetSet2 = mutable.Set(\"tiny2\",\"nico\")\n    jetSet+=\"tiny\"\n    jetSet2+=\"negopa\"\n    println(jetSet)\n    println(jetSet2)\n    val treasureMap = mutable.Map[Int,String]()\n    treasureMap+=(1 -> \"My\")\n    treasureMap+=(2 -> \"Name\")\n    treasureMap+=(3 -> \"is\")\n    println(treasureMap(2))\n    val rumerNum = Map(1 -> \"I\",2 -> \"II\",3 -> \"III\",4 -> \"IV\")//不可变映射\n    rumerNum.foreach(s => println(s._2))\n  }\n}\n```","tags":["语言学习基础"]},{"title":"Scala辅导班(一) 使用列表","url":"/2019/12/31/Scala辅导班（一）使用列表/","content":"新年快乐，2020，向前冲！\n语言：scala 2.12\n## 数组定义\n```bash\nval numNames = Array(\"num1\",\"num2\",\"num3\")\n```\n数组定义的一般形式\n```bash\nval numNames2 = Array.apply(\"num1\",\"num2\",\"num3\")\n```\n数组定义的等价形式，使用apply方法，scala语言的本质\n## 列表定义\n```bash\nval OneTwo = List(1,2)\nval ThreeFour = List(3,4)\n```\n列表定义\n```bash\nval OneTwoThreeFour = OneTwo ::: ThreeFour\n```\n列表衔接\n```bash\nval TwoThreeFour = 2::ThreeFour\n```\n向表头添加元素，为什么是向头部添加，因为向后添加会消耗线性时间，与其这样不如向表头添加，再通过反转，就能完成同样的功能\n## 列表常用方法\n```bash\nval thrill = \"nil\"::\"sekiro\"::\"thunder\"::Nil\nprint(thrill.count(s => s.length>=4))\nprint(thrill.filter(s => s.length>=4))\nprint(thrill.forall(s => s.endsWith(\"l\")))\nthrill.foreach(s => println(s))\nprint(thrill.mkString(\",\"))//返回以\",\"分割组成的一个列表\n```\n自己动手实践，不多讲","tags":["语言学习基础"]},{"title":"Spark学习（二）概念梳理","url":"/2019/12/29/Spark学习（二）概念梳理/","content":"\n伟大领袖，天降伟人的刘老师给我们的spark概念图\n{% img /img/Spark.png 800 450 %}\n## 分区\nSpark的分区是逻辑上的分区。执行过程中有多少个Task是由RDD分区决定的。同时运行几个Task是由分配给Executor的Core的数量决定的。\n## 什么时候分区\n·分区数量从少到多·处理能力不够·数据倾斜·需要合并场景\n## cache缓存\n持久化方法，将RDD放入内存中，减少重复计算,一共有12种\n    例：\n    ```bash\n    val MEMORY_AND_DISK = new StorageLevel(true, true, false, true)\n    ```\n//第一个参数，放到磁盘\n    //第二个参数，放到内存\n    //第三个参数，磁盘中的数据，不是以java对象的方式保存\n    //第四个参数，内存中的数据，以java对象的方式保存\n## checkpoint机制\n将RDD存储在本地磁盘或者HDFS中，通过直接读取检查点目录的数据来恢复相应的RDD\n## 宽依赖窄依赖\n    宽依赖：一个父RDD和一个或多个子RDD\n    窄依赖：一个子RDD和一个或多个父RDD\n## 广播\n将数据块缓存到所有节点\n## 启动流程(9step)\n    1、跟Master建连接并申请资源，每个Executor需要 3g 内存，一共4 cores\n    2、Master进行资源调度\n    3、Master跟Worker进行rpc通信，让Worker创建Executor\n    4、Worker启动Executor\n    5、Executor跟Driver进行通信\n    6、RDD触发Action后，会根据最后这个RDD从后往前推断依赖关系，遇到shufle就切分Stage，会递归切分，递归的出口是某个RDD没有父BDD了\n    7、DAGScheduler切分完Stage后，先提交前面的Stage,执行完后在提交后面的Stage，Stage会生产Task，一个Stage 会生产很多业务逻辑相同的Task，然后将以TaskSet的形式传递给TaskScheduler\n    8、 TaskScheduler将Task序列化，根据资源情况，发送Task给Executor\n    9、Executor接收到Task后，先将Task反序列化，然后将Task用一个实现了Runnable接口的实现类包装起来，然后将该包装类丢入到线程池，然后包装类的run方法就会被执行，进而调用Task的计算逻辑\n## DStream\nDstream为每一批次的数据生成一个RDD实例，就是一个RDD序列\n## 几何平均数\n{% img /img/jihe.png 150 100 %}\n## UDF用户自定义函数\n一对一的用户定义函数，例如\n```bash\nspark.sql(\"SELECT name,age,from_unixtime(create_time,'yyyy-MM-dd HH:mm:ss') FROM t_usr\").show\n```\n实现用户自定义函数\n```bash\nspark.udf.register(\"func_name\",方法体)\n```\n多进一出UDAF（多对一）\n","tags":["大数据技术"]},{"title":"Spark学习（一）Spark集群模式讲解","url":"/2019/12/28/Spark学习（一）Spark集群模式讲解/","content":"  小坚又被Spark教训了，下面重点讲解Spark的集群\n  下面详细列举了Spark目前支持的部署模式。\n· Local模式：在本地部署单个Spark服务\n· Standalone模式：Spark自带的任务调度模式（国内常用)\n· Yarn模式：Spark使用Hadoop的YARN组件来进行\n· Mesos模式：Spark使用Mesos平台进行资源与任务的调度\n· Kubernetes模式：自Spark2.3.x版本之后才开始支持Kubernetes","tags":["大数据技术"]},{"title":"数据结构与算法（五）科赫曲线","url":"/2019/12/21/数据结构与算法（五）科赫曲线/","content":"语言：python\n递归就是常说的套娃，\n在递归函数中直接或间接调用函数，就是递归\n科赫曲线是在无限的长度中圈定有限的面积，\n实现为三步：1.找到三等分点S,T 2.做等边三角形 3.再对线段进行调用\n```bash\n#科赫曲线\nimport turtle as t\ndef koth(size,n):\n    if n==0:\n        t.fd(size)\n    else:\n        for seta in [0,60,-120,60]:\n            t.left(seta)\n            koth(size/3,n-1)\nif __name__ == '__main__':\n    koth(200,3)\n```","tags":["数据结构与算法"]},{"title":"数据结构与算法（四）穷举搜索","url":"/2019/12/21/数据结构与算法（四）穷举搜索/","content":"运行环境：python 3.7 Dev-C++\n判断是否A中的任意元素都能能够组成整数m?\npython版:\n```bash\nA = [1,5,7,10,21]\nn = len(A)\ndef solve(i,m):\n    if m==0:\n        return True\n    elif i>=n:\n        return False\n    res = solve(i+1,m) or solve(i+1,m-A[i])\n    return res\nif __name__ == '__main__':\n        if(solve(0,8)):\n            print(\"yes\")\n        else:\n            print(\"no\")\n```\nc语言版:\n```bash\n#include<stdio.h>\nint n,A[50];\nint solve(int i,int m){\n\tif (m ==0)return 1;\n\tif (i>=n)return 0;\n\tint res = solve(i+1,m)||solve(i+1,m-A[i]);\n\treturn res; \n} \nint main(){\n\tint q,M,i;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++) scanf(\"%d\",&A[i]);\n\tscanf(\"%d\",&q);\n\tfor(i=0;i<q;i++){\n\t  scanf(\"%d\",&M);\n\t  if(solve(0,M)) printf(\"yes\\n\");\n\t  else printf(\"no\\n\"); \n}\nreturn 0;\n}\n```\n","tags":["数据结构与算法"]},{"title":"数据结构与算法（三）分治与递归","url":"/2019/12/21/数据结构与算法（三）分治与递归/","content":"运行环境：python 3.7\n将问题分解\n函数->递归函数->分治法\n本篇介绍递归和分治\n```bash\ndef factorial(n):\n    if n == 1:\n        return 1\n    else:\n        return n*factorial(n-1)\ndef findMaximum(A,l,r):\n    m = (l+r)//2\n    if l == r-1:\n        return A[l]\n    else:\n        u = findMaximum(A,l,m)\n        v = findMaximum(A,m,r)\n        x = max(u,v)\n    return x\nif __name__ == '__main__':\n    print(factorial(4))\n    A = [1,2,4,2,3,4,6]\n    print(findMaximum(A,0,7))#l到r（不包括r）\n```\n结果如下\n![](/img/分治与递归.png)\n","tags":["数据结构与算法"]},{"title":"数据结构与算法（二）散列法","url":"/2019/12/21/数据结构与算法（二）散列法/","content":"运行环境：Dev-C++\n题目要求：\n请实现一个能执行以下命令的简单“字典”\ninsert str:向字典中添加字符串\nfind str:当前字典中包含str时输出yes，不包含str时输出no\n主要思想：将字符转变成数字，并使用散列函数H(k) = (h1(k)+i*h2(k))mod m\nh1(k)=k mod m\nh2(k)=1+ k mod (m-1)\n代码如下\n```bash\n#include<stdio.h>\n#include<string.h>\n\n#define M 1046527\n#define NIL (-1)\n#define L 14\n\nchar H[M][L];\n\nint getChar(char ch){\n\tif(ch=='A')return 1;\n\telse if(ch=='C')return 2;\n\telse if(ch=='G')return 3;\n\telse if(ch=='T')return 4;\n\telse return 0;\n} \nlong long getKey(char str[]){\n\tlong long sum=0,p=1,i;\n\tfor(i=0;i<strlen(str);i++){\n\t\tsum+=p*(getChar(str[i]));\n\t\tp*=5;\n\t}\n\treturn sum; \n}\nint h1(int key){\n\treturn key%M;\n}\nint h2(int key){\n\treturn 1+(key%(M-1));\n}\nint find(char str[]){\n\tlong long key,i,h;\n\tkey=getKey(str);\n\tfor(i=0;;i++){\n\t\th=(h1(key)+i*h2(key))%M;\n\t\tif(strcmp(H[h],str)==0)return 1;\n\t\telse if(strlen(H[h])==0)return 0;\n\t}\n\treturn 0;\n}\nint insert(char str[]){\n\tlong long key,i,h;\n\tkey = getKey(str);\n\tfor(i=0;;i++){\n\t\th=(h1(key)+i*h2(key))%M;\n\t\tif(strcmp(H[h],str)==0)return 1;\n\t\telse if(strlen(H[h])==0){\n\t\t\tstrcpy(H[h],str);\n\t\t\treturn 0;\n\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint i,n,h;\n\tchar str[L],com[9];\n\tfor(i=0;i<M;i++)H[i][0]='\\0';\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%s %s\",com,str);\n\t\t\n\t\tif(com[0]=='i'){\n\t\t\tinsert(str);\n\t\t}else{\n\t\t\tif(find(str)){\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n结果如下：\n![](/img/散列法.png)\n\n\n","tags":["数据结构与算法"]},{"title":"数据结构与算法（一）二分查找","url":"/2019/12/21/数据结构与算法（一）二分查找/","content":"运行环境：Dev-C++\n题目要求：\n有一含n个整数的数列S，含q个不相同整数的T，限制：S为升序排列\n请找出既在S又在T的整数的个数？\n代码如下\n```bash\n#include<stdio.h>\nint A[10000],n;\nbinarySearch(int key){\n\tint left=0;\n\tint right=n;\n\tint mid;\n\twhile (left<right){\t\n\t\tmid=(left+right)/2;\n\t\tif(key==A[mid])return 1;\n\t\tif(key>A[mid])left=mid+1;\n\t\telse if(key<A[mid])right=mid;\n}\n\treturn 0;\n}\nint main(){\n\tint i,q,k,sum=0;\n\tscanf(\"%d\",&n);\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d\",&A[i]);\n\t}\n\tscanf(\"%d\",&q);\n\tfor(i=0;i<q;i++){\n\t\tscanf(\"%d\",&k);\n\t\tif(binarySearch(k))sum++;\n\t}\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n} \n```\n结果如下：\n![](/img/二分查找.png)","tags":["数据结构与算法"]}]